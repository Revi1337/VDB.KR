package com.revi1337.repository;

import com.revi1337.QueryDslTestConfig;
import com.revi1337.config.domain.JPAConfig;
import com.revi1337.domain.Vulnerability;
import com.revi1337.dto.response.statistics.TotalByYearResponse;
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import jakarta.persistence.Tuple;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.context.annotation.Import;
import org.springframework.test.annotation.Commit;

import java.time.Instant;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;

@Import({JPAConfig.class, QueryDslTestConfig.class})
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
@DataJpaTest(showSql = false) @Commit
class VulnerabilityRepositoryTest {

    private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ISO_LOCAL_DATE_TIME;

    private final VulnerabilityRepository vulnerabilityRepository;

    @PersistenceContext EntityManager entityManager;

    @Autowired
    public VulnerabilityRepositoryTest(VulnerabilityRepository vulnerabilityRepository) {
        this.vulnerabilityRepository = vulnerabilityRepository;
    }

    @Test
    @DisplayName(value = "[Repository : CVE_ID 로 조회]")
    public void searchByCveId() {
        List<Vulnerability> resultList = entityManager.createQuery("select v from Vulnerability as v inner join v.metrix as m where v.cveId = :cveId", Vulnerability.class)
                .setParameter("cveId", "CVE-2017-0144")

                .getResultList();
        for (Vulnerability vulnerability : resultList) {
            System.out.println("vulnerability = " + vulnerability);
        }
    }

    @Test
    @DisplayName(value = "[Repository : PUBLISHED 로 조회]")
    public void searchByPublishedTest() {
        List<Vulnerability> dateTime = entityManager.createQuery("select v from Vulnerability as v inner join v.metrix as m where v.published >= :dateTime", Vulnerability.class)
                .setParameter("dateTime", LocalDateTime.now().minusDays(365))
                .getResultList();
        System.out.println("dateTime = " + dateTime.size());
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    @Test
    @DisplayName(value = """
        [Repository : 년도별 존재하는 CVE 총 개수 조회 - via JPQL (RAW)]
        [NATIVE SQL : select year(published) as result, count(*) from vulnerability group by year(published);]
    """)
    public void searchEachYearTotalByRAWJPQL() {
        List<Tuple> resultList = entityManager.createQuery(
                        "select function('year', v.published) as result, count(v) as total" +
                                " from Vulnerability as v" +
                                " group by function('year', v.published)", Tuple.class)
                .getResultList();
        for (Tuple tuple : resultList) {
            System.out.println(tuple.get(0) + " : " + tuple.get(1));
        }
    }

    @Test
    @DisplayName(value  = """
        [Repository : 년도별 존재하는 CVE 총 개수 조회 - via JPQL (new Projection)]
        [NATIVE SQL : select year(published) as result, count(*) from vulnerability group by year(published);]
    """)
    public void searchEachYearTotalByJPQLNewProjection() {
        List<TotalByYearResponse> resultList = entityManager.createQuery(
                        "select new com.revi1337.dto.response.statistics.TotalByYearResponse(function('year', v.published), count(v))" +
                                " from Vulnerability as v" +
                                " group by function('year', v.published)", TotalByYearResponse.class)
                .getResultList();
        for (TotalByYearResponse totalByYearResponse : resultList) {
            System.out.println("totalByYearResponse = " + totalByYearResponse);
        }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    @Test
    public void localDateTimeTest() {
        String seed = "2017-03-17T00:59:04.010";

        LocalDateTime now = LocalDateTime.now();
        System.out.println("now = " + now);

        Instant now1 = Instant.now();
        System.out.println("now1 = " + now1);
        LocalDateTime parsedLocalDateTime = LocalDateTime.parse(seed, FORMATTER);
        System.out.println("parsedLocalDateTime = " + parsedLocalDateTime);
    }
}

